(in-package #:aoc-2024.day4)

(defun find-all-paths (grid word)
  (declare (type (array character (* *)) grid)
           (type string word))
  (let ((paths nil)
        (word-len (length word))
        (directions '((-1 -1) (-1 0) (-1 1)
                      (0 -1)        (0 1)
                      (1 -1)  (1 0)  (1 1))))
    (labels ((valid-pos-p (row col char)
               (and (>= row 0)
                    (>= col 0)
                    (< row (array-dimension grid 0))
                    (< col (array-dimension grid 1))
                    (char= (aref grid row col) char)))
             
             (search-from-pos (pos dir-idx word-idx path)
               (if (= word-idx word-len)
                   (push path paths)
                   (when dir-idx  ; if we have a direction, keep going that way
                     (let* ((dir (nth dir-idx directions))
                            (new-row (+ (car pos) (first dir)))
                            (new-col (+ (cdr pos) (second dir))))
                       (when (valid-pos-p new-row new-col (char word word-idx))
                         (search-from-pos (cons new-row new-col)
                                          dir-idx
                                          (1+ word-idx)
                                          (cons (cons new-row new-col) path))))))))
      
      (dotimes (i (array-dimension grid 0))
        (dotimes (j (array-dimension grid 1))
          (when (char= (aref grid i j) (char word 0))
            (let ((start-pos (cons i j)))
              (dotimes (dir-idx (length directions))
                (search-from-pos start-pos dir-idx 1 (list start-pos))))))))
    paths))

(defun visualize-word-search (filename word)
  (let* ((grid (read-input filename))
         (x-bound (array-dimension grid 0))
         (y-bound (array-dimension grid 1)))
    (format t "Original grid:~%")
    (dotimes (i x-bound)
      (dotimes (j y-bound)
        (format t "~A " (aref grid i j)))
      (format t "~%"))
    (let* ((paths (find-all-paths grid word))
           (answer (length paths)))
      (visualize-paths grid paths word))))

(defun solve-day4 (filename word)
  (let* ((grid (read-input filename))
         (paths (find-all-paths grid word))
         (answer (length paths)))
    answer))

(defun read-input (filename)
  (let* ((str (alexandria:read-file-into-string filename))
         (lines (remove-if #'uiop:emptyp (uiop:split-string str :separator '(#\Newline))))
         (rows (length lines))
         (cols (length (first lines))))
    (make-array (list rows cols) 
                :element-type 'character
                :initial-contents (mapcar (lambda (line) 
                                            (coerce line 'list)) 
                                          lines))))

(defun visualize-paths (grid paths word)
  (declare (type (array character (* *)) grid))
  (let* ((rows (array-dimension grid 0))
         (cols (array-dimension grid 1))
         (display-grid (make-array (list rows cols) :initial-element #\.)))
    ;; Count how many paths use each position
    (dolist (path paths)
      (dolist (pos path)
        (let ((current (aref display-grid (car pos) (cdr pos))))
          (setf (aref display-grid (car pos) (cdr pos))
                (if (char= current #\.)
                    #\1
                    (digit-char (1+ (digit-char-p current))))))))
    
    (format t "~%Found ~D instances of '~A':~%" (length paths) word)
    (dotimes (i rows)
      (dotimes (j cols)
        (format t "~A " (aref display-grid i j)))
      (format t "~%"))
    (length paths)))

(defun find-x-mas-patterns (grid)
  (declare (type (array character (* *)) grid))
  (let ((paths nil)
        (rows (array-dimension grid 0))
        (cols (array-dimension grid 1)))
    (labels ((valid-pos-p (row col)
               (and (>= row 0) (>= col 0)
                    (< row rows) (< col cols)))
             (check-diagonal-pair (a-row a-col dr dc)
               "Check if we have M and S in mirrored positions on this diagonal"
               (let ((pos1-row (+ a-row dr))
                     (pos1-col (+ a-col dc))
                     (pos2-row (- a-row dr))
                     (pos2-col (- a-col dc)))
                 (when (and (valid-pos-p pos1-row pos1-col)
                            (valid-pos-p pos2-row pos2-col))
                   (let ((char1 (aref grid pos1-row pos1-col))
                         (char2 (aref grid pos2-row pos2-col)))
                     (when (or (and (char= char1 #\M) (char= char2 #\S))
                               (and (char= char1 #\S) (char= char2 #\M)))
                       (list (cons pos1-row pos1-col) 
                             (cons a-row a-col)
                             (cons pos2-row pos2-col))))))))
      
      ;; For each A in the grid
      (dotimes (i rows)
        (dotimes (j cols)
          (when (char= (aref grid i j) #\A)
            ;; Check both diagonal pairs
            (let ((diag1 (check-diagonal-pair i j 1 1))   ; top-left to bottom-right
                  (diag2 (check-diagonal-pair i j 1 -1))) ; top-right to bottom-left
              (when (and diag1 diag2)
                (push (append diag1 diag2) paths)))))))
    paths))

(defun solve-day4-part2 (filename)
  (let* ((grid (read-input filename))
         (paths (find-x-mas-patterns grid))
         (answer (length paths)))
    answer))

